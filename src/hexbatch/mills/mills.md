\page HexbatchMills ðŸ­ Mills


## Introduction

Mills are used to build shells, elements, interfaces, instances, semaphores, hooks, and promises. Basically, if something needs to store data, and do some logic; then they need to be from a mill. Once a mill is defined , it can crank out copies of the same things, if need be. Copies always go on a stack. Not everything needs copies, though. Some things defined by mills, like interfaces or gems or semaphores, only have one copy at a time.  Mills have three basic components

ðŸ“¦ Boxes are used to store data, and give details about the data.  Some of this data goes away, erased, never to be seen again, when some things finish up what they are doing. This type of data is called dynamic data here. Some data is shared between all copies generated by the one mill. This is called static data. And some data does not go away but is not shared, it is for that once copy only. This is called persistent data.

ðŸšŒ Buses do three things. They provide connections between the different things that make up a mill. They count tags used (pushed), or unused (popped). And they group things together into collections. They send signals to the logic when something has changed in the mill (or a copy on the stack)

âš™ Logic decides what to do based on the state of the bus. Logic is powered by tag collections, but can also make rules if a set of tags is missing too.  Logic can push or pop tags, to start other logic decisions. Logic can also turn things on and off. Logic knows how to wait on a semaphore

  âš™ ðŸ Logic triggers listen for changes and decide if an action should be fired

  âš™ â–¶ Logic actions are what happens after a trigger is truthful , several actions can be on the same trigger





â‰£ Stacks are when mills have copies. These copies can have children of their own. When copied, the new copy is pushed down on the mill stack. Some of the data is shared with the parent, so an update to one is an update to all. Other data is just used inside the copy. These copies can be erased (popped off the stack)

â‰£ ðŸ“¦ stacked boxes are boxes of mills put on the stack

â‰£ ðŸšŒ stacked buses are buses of mills put on the stack

Mills can be organized, where there are children and parents. For example , a ðŸš shell has â™Ÿ elements, and an ðž´  interface has ðŸ’Ž gems made up of shells

ðŸ­ ðŸ‘ª mill inheritance allows inherited buses and boxes and logic to be altered or removed without copying over the unchanging data

ðŸ­ ðŸ“‚  mill organization will set up the child parent relationships in the structures, and allow group membership from copied organizations to be altered without copying unchanging data


## ðŸŒˆ Segment : One ring to bind them all

All of the different components of a mill (box, bus, logic (operations and actions), stack, shells, elements, gems, mill relations and inheritance and overrides) all use the same data structure/db table. This is useful/needed for the organizing of these through selections later

The type of thing each segment is can be determined by the trait role, as every entry here has its own dedicated trait

each different âš‘ flag value, across all columns in this table, has a different integer representing it, so that it's easy to find, set,  mix and match different flags  and see what is valid

If a trait has write access to the id-trait, then that trait has permissions to write to any part of that segment, and can delete it. Segments who have id-traits that are system traits can only be deleted by other system traits


### Segment data structure (table)



*   ðŸ†” ðŸ”¤ GUID
    *   **Auto generated string guid, can use in api calls**
*   / ðŸ­ mill owner
    *   The mill this belongs to
    *   This can be null for selections
*   / ðŸ†”  the id-trait
    *   which gives this identity, permissions, relationship and ownership
*   ðš« json data
    *   ðŸ“¦ for boxes, this is where the main info is stored
    *   â‰£ ðŸ“¦  for stacked boxes, this is there copy of the data of the box they use
    *   ðŸ“£ semaphores, properties stored in two keys
    *   âˆ« ðŸ selection rules, when they use literal data
    *   âˆ« â–¶ selection actions, when it uses literal data for args to its operations
        *   will always be numbers or strings, no geometry needed
    *   selection-active-paging, stores the variables (all of them in one json)
    *   **Geometric data can also be stored in the area and location too, however, when that happens, the geo-json its from is found here**
*   ðŸ’  multipolygon for associating area
    *   ðŸ“¦ for boxes, stores the area set by the geojson in the ðš« data
    *   â‰£ ðŸ“¦  for stacked boxes, stores overridden (their copy) area from their data
    *   âˆ« ðŸ selection rules, when the ðš« data has geojson area
*   ðŸ“ location for a place in the world, or other
    *   ðŸ“¦  for boxes, stores the point set by the geojson in the ðš« data
    *   â‰£ ðŸ“¦  for stacked boxes, stores overridden (their copy) point from their data
    *   âˆ« ðŸ selection rules, when the ðš« data has geojson location
*   / ðŸŒ mapped world trait
    *   â‰£ for stacks, there needs to be one world it belongs to
*   / â—“ shard trait
    *   Everything with location belongs to a shard
*   / ðŸŒ nested world trait
    *   nested worlds do not interact, just run in the same library
    *   nested worlds can have their own mapped worlds
*   / parent trait
    *   âš™ â–¶  for logic actions, this connects them with the logic trigger
    *   â‰£ for stacks, this is the parent pointer (can be null if this is the first stack for it)
    *   â‰£ ðŸšŒ for stacked buses, this is the stack owner
    *   â‰£ ðŸ“¦  for stacked boxes, this is the stack owner
    *   ðŸ­ ðŸ“‚  for mill organization, this is the organization which is copied
    *   âˆ« â–¶ selection actions, this connects them with the âˆ« ðŸ selection rule
    *   selection-active-paging, this connects them with the âˆ« ðŸ selection rule
    *   ðŸ“£ semaphores,when a context is given, then a child of the semaphore will be spun up and given its own row
*   / ð° the alpha trait, which is used differently for each role
    *   ðŸ“¦ for boxes, a possible link to another trait id that describes this box. This is called the descriptor trait
    *   ðŸšŒ for buses, this is the first trait
    *   âš™ ðŸ  for logic triggers, this is the first operand trait_ _
    *   âš™ â–¶ for logic actions, this is the action tag
    *   â‰£ for stacks, this is the context
    *   â‰£ ðŸšŒ for stacked buses, this is the first trait
    *   ðŸ­ ðŸ‘ª for mill inheritance, this is the parent ðŸ­ mill
    *   ðŸ­ ðŸ“‚  for mill organization, this is the owner ðŸ­ðŸ“‚ Mill Organization
    *   âˆ« ðŸ selection rules, this is the first operand trait
    *   âˆ« â–¶ selection actions, this is the first operand trait
*   / ðž«  the beta trait, which is used differently for each role
    *   ðŸ“¦ âˆ« for boxes, stores the selection trait
    *   ðŸšŒ for buses, this is the second trait
    *   âš™ ðŸ  for logic triggers, this is the second operand trait
    *   âš™ â–¶ for logic actions, this is the association tag
    *   â‰£ ðŸšŒ for stacked buses, this is the second trait
    *   â‰£ ðŸ“¦ âˆ« for stacked boxes, stores overridden (their copy) selection
    *   ðŸ­ ðŸ‘ª for mill inheritance, this is the child ðŸ­ mill
    *   ðŸ­ ðŸ“‚  for mill organization, this is the child  ðŸ­ mill
    *   âˆ« ðŸ selection rules, this is the second operand trait
    *   âˆ« â–¶ selection actions, this is the second operand trait
*   / ð® the grouping trait
    *   ðŸšŒ for buses, this is used to form collections and bind group buses for logic
    *   âš™ â–¶ for logic actions, this is the grouping trait
    *   âš™ ðŸ  for logic triggers, this is the bus group that will active the top rule
    *   â‰£ ðŸšŒ for stacked buses, this is local collection trait
    *   ðŸ­ ðŸ“‚  for mill organization, this is the child being added or removed from a copied structure
    *   ðŸ­ ðŸ‘ª for mill inheritance, this lists the trait (bus,box,logic) that is being overridden
*   / â—Ž the target trait
    *   âš™ â–¶ for logic actions, this is used to define the target of the action
    *   âš™ ðŸ  for logic triggers, this is the bus that will active the top rule
    *   â‰£ ðŸšŒ for stacked buses, this is the ðŸšŒ pointer to the original bus
    *   ðŸ­ ðŸ‘ª for mill inheritance, this maps what the grouping trait (the overridden) is being mapped to. Can be null to make it map to nothing
    *   âˆ« â–¶ for selection actions, this is trait that receive the results of the api call in the ðš« json  , it must have an entry on the segments
    *   ðŸ“£ semaphores,when emitting, only this stack â‰£  and its children can hear this
*   âš‘ operational flag, which is used differently for each role
    *   ðŸ“¦  for boxes, can a descendant â‰£ ðŸ“¦ write to this ?
    *   â‰£ ðŸ“¦  for stacked boxes, can a descendant â‰£ ðŸ“¦ write to this ?
    *   âš™ ðŸ  for logic triggers, this is the operator
    *   â‰£ for stacks, this shows if there can be dynamic data copying
    *   ðŸ­ ðŸ“‚  for mill organization, this shows if we are adding or removing the child from the inherited list
    *   âˆ« ðŸ selection rules, this is the operator
    *   âˆ« â–¶ selection actions, this is the operator
*   âš‘ descriptor flag, which is used differently for each role
    *   ðŸšŒ for buses, it is the type of bus entry
    *   ðŸ“¦  for boxes, this gives hints on how to share the dynamic data with other worlds
*   âš‘ contextual flag, which is used differently for each role
    *   ðŸšŒ for buses, tells if this is dynamic or static
    *   ðŸ“¦ for boxes, tells if this is dynamic or static
    *   ðŸ­ ðŸ‘ª for mill inheritance, this is the type of role the child does
    *   ðŸ­ ðŸ“‚  for mill organization, this is the type of relationship
    *   âˆ« â–¶ selection actions,  how to use the selection results in that call
*   â„¤ ð° counter, which is used differently for each role
    *   ðŸšŒ for buses, is the tag counter
    *   â‰£ for stacks, this is the number of child stacks allowed
    *   â‰£ ðŸšŒ for stacked buses, is the current tag counter
    *   âš™ ðŸ  for logic triggers, is the order which top rules will run
    *   âš™ â–¶  for logic actions, is the order which top actions will run for the same rule
    *   âˆ« ðŸ selection rules, the size of the page
    *   âˆ« â–¶ selection actions, tells how many actions to do per page
    *   selection-active-paging, the current page
    *   ðŸ“£ semaphores,the minimum number of emit commands needed to toggle this emit
*   â„¤ ðž« counter, which is used differently for each role
    *   ðŸ“¦ for boxes, â†ª  turn this was last updated on
    *   â‰£ for stacks, , â†ª  turn this was last updated on
    *   â‰£ ðŸšŒ for stacked buses, is the old tag counter
    *   â‰£ ðŸ“¦  for stacked boxes, â†ª  turn this was last updated on
    *   selection-active-paging, turn this page was created on
    *   âˆ« â–¶ selection actions, tells how many pages to do actions on
    *   ðŸ“£ semaphores,the number of emit commands given to it
    

## ðŸ‘ª Inheritance of ðŸ­ mills


### Inheritance

New mills can be made from multiple inheritance of other mills. While new copies of a mill are put on the stack, new mills are copies with nothing on the stack. If the new mill does not override the ðŸ“¦ boxes, âš™ logic, or ðŸšŒ  buses of the parent, then the parent can be used to select the child (or descendants)

Since there can be multiple inheritance, and ancestors can block selections by overriding parents. There is a table for inheritance in mills

In the data structures, simply create a new trait which will be the parent, and then add in the inheritance to the table below. There will be no new  buses, logic or boxes made. The descendants share any static data or settings. But, the descendants can create new boxes, logic and buses. If the new ones do not change the inherited ones (use the same traits in the sub structures and add or remove things that modify them), then this inheritance is called pure. However, pure descendants can add in unrelated things that do not impact the ancestor data or behaviors, and still be pure

Any child can override a bus,box, logic from an ancestor. If this has multiple inheritance which has two or more ancestors that share the same sub structure trait for a bus,box or logic, then one is randomly chosen, unless there is a mapping

Mills can be created to inherit and override other mills, and mill can have structures made out of other mills

A child mill will inherit all the sub mills without creating new entries, any changes to any gems inherited, for example, will create a entry in the mill organization structure, which flags what kind of change this is, and will automatically will mark the inheritance as not pure

To be considered a change of inherited mill organization, the relationship type must be the same as one of the types the parent uses. If the child uses a new type of relationship, then the changes do not pure state


### ðŸ­ ðŸ‘ª  Mill Inheritance data



*   / ðŸ­ mill owner
    *   The mill that owns this ðŸ‘ª ðŸ­  rule. This will be the new mill that is created by these rules
*   / ðŸ†”  the id-trait
    *   the unique trait generated for this  ðŸ‘ª ðŸ­ rule
    *   all ðŸ‘ª rules for the ðŸ­ are siblings
*   / ð° the alpha trait
    *   ðŸ­ ðŸ‘ª for mill inheritance, this is the parent ðŸ­ mill that we are inheriting from
    *   Can be null if we are creating a brand new mill, to define it to have a role
*   / ðž«  the beta trait
    *   ðŸ­ ðŸ‘ª for mill inheritance, this is the child ðŸ­ mill that inherits
*   / ð® the grouping trait
    *   ðŸ­ ðŸ‘ª for mill inheritance, this lists the trait (bus,box,logic) that is being overridden
*   / â—Ž the target trait
    *   ðŸ­ ðŸ‘ª for mill inheritance, this maps what the grouping trait (the overridden) is being mapped to. Can be null to make it map to nothing
    *   Mapping has to stay in the same type: map bus to bus, for example
*   âš‘ contextual flag
    *   ðŸ­ ðŸ‘ª for mill inheritance, this is the type of role the child does
    *   if several rows define this inheritance, it only has to be set once, and the rest of the rows it can be null
    *   it must be set once and only once for each mill created


## ðŸ“‚ ðŸ­ Grouping and Structures of Mills

 Usually , Mills do not operate alone, and are organized to work together. For example, interfaces have gems, shells have element lists, promises have handlers 

 Mills that do not inherit a structure from a parent make their own lists 

\section MillOrganization  Mill Organization Data


@spec Go into detail how the organized mills get put into  a stack at the same time


*   / ðŸ­ mill owner
    *   The mill that owns this ðŸ“‚  ðŸ­  rule
*   / ðŸ†”  the id-trait
    *   the unique trait generated for this ðŸ“‚  ðŸ­  rule
    *   all ðŸ“‚  rules for the ðŸ­ are siblings
*   / parent trait
    *   ðŸ­ ðŸ“‚  for mill organization, this is the organization which is copied
    *   can be null if this starts a new organization
*   / ð° the alpha trait
    *   ðŸ­ ðŸ“‚  for mill organization, this is the owner ðŸ­ðŸ“‚ Mill Organization
*   / ðž«  the beta trait
    *   ðŸ­ ðŸ“‚  for mill organization, this is the child  ðŸ­ mill
*   / ð® the grouping trait
    *   ðŸ­ ðŸ“‚  for mill organization, this is the child being added to or removed  from the parent organization
    *   if there is no parent organization, this defines the list
*   âš‘ operational flag
    *   ðŸ­ ðŸ“‚  for mill organization, this shows if we are adding or removing the child from the inherited list
*   âš‘ contextual flag
    *   ðŸ­ ðŸ“‚  for mill organization, this is the type of relationship


## @ Tags and how they are used

Tags are used to store state. Symbolized by the @ symbol here, they are traits that are of type tag. A trait that is used as a tag cannot be used as anything else, but anything that can select that tag can use it for associative tagging, and anything that has permission to write to the bus trait , and can see a tag, can tag that bus with that tag

Tags can be pushed (add a row or count) or popped (remove a row or decrease the count) from a bus on a mill or stack.  When a tag is pushed onto a  trait, if there is no extra data in that push other than the tag.Then this is called a regular tag. And this kind of tag only has one entry on the bus. The number of times that tag is pushed - the number of times that tag is popped, is kept as the count on that bus entry.  The tag number can never get less than 0, no matter how many times it's popped, but can be any positive number based on how many times that it is pushed. A tag is present anytime its count is > 0.

ðŸ‘£ A associated tag can be assigned a trait to pair up with, regardless of permissions. If the associated tag is pushed twice with the same trait, then its count increases just like a regular tag that has no associated data. And that count is kept on the bus entry which has that pair recorded

Associated tags is how we store collections or groups

Tags can be related together in two ways.



*    Through relationship (all the tags of one thing can be descended from a certain tag, to treat it like a file structure, if needed)
*   And each tag can be given a group on the bus
    *   This group trait does not have to be related to anything
    *   If the same tag is pushed with a different group from last time, then that is a new bus entry, regardless if there is also associated data

    Selections can use tag relationships to filter out and focus only on some things. In addition, the caller of the selection can use its associated tags to pre-filter the selection

The general rule of thumb is that tags can be pushed and popped from a bus by anything that has permission, and that is how that mill or element state is maintained, if the logic on there will listen to the tags. If a tag is pushed or popped from a bus, and no logic rules are listening to that bus trait (or family as new buses have descendant traits related to the older ones), then the tag push or pop may help with selections done by other things later