<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>HexBatch Core: ğŸ­ Mills</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">HexBatch Core
   &#160;<span id="projectnumber">pre-alpha</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">ğŸ­ Mills </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md114"></a>
Introduction</h1>
<p>Mills are used to build shells, elements, interfaces, instances, semaphores, hooks, and promises. Basically, if something needs to store data, and do some logic; then they need to be from a mill. Once a mill is defined , it can crank out copies of the same things, if need be. Not everything needs copies, though. Some things defined by mills, like interfaces or gems or semaphores, only have one copy at a time. Mills have three basic components</p>
<p>ğŸ“¦ Boxes are used to store data, and give details about the data. Some of this data goes away, erased, never to be seen again, when some things finish up what they are doing. This type of data is called dynamic data here. Some data is shared between all copies generated by the one mill. This is called static data. And some data does not go away but is not shared, it is for that once copy only. This is called persistent data.</p>
<p>ğŸšŒ Buses do three things. They provide connections between the different things that make up a mill. They count tags used (pushed), or unused (popped). And they group things together into collections</p>
<p>âš™ Logic decides what to do based on the state of the bus. Logic is powered by tag collections, but can also make rules if a set of tags is missing too. Logic can push or pop tags, to start other logic decisions. Logic can also turn things on and off. Logic knows how to wait on a semaphore</p>
<p>âš™ ğŸ Logic triggers listen for changes and decide if an action should be fired</p>
<pre class="fragment">âš™ â–¶ Logic actions are what happens after a trigger is truthful , several actions can be on the same trigger
</pre><p>â‰£ Stacks are when mills have copies that are used in a run context. These copies can have children of their own , the mill is pushed down on the stack again with copies of the data in its parent. Or these copies can be erased</p>
<p>â‰£ ğŸ“¦ stacked boxes are boxes put on the stack</p>
<p>â‰£ ğŸšŒ stacked buses are buses put on the stack</p>
<p>Mills can be organized, where there are children and parents. For example , a ğŸš shell has â™Ÿ elements, and an ğ´ interface has ğŸ’ gems made up of shells</p>
<p>ğŸ­ ğŸ‘ª mill inheritance allows inherited buses and boxes and logic to be altered or removed without copying over the unchanging data</p>
<p>ğŸ­ ğŸ“‚ mill organization will set up the child parent relationships in the structures, and allow group membership from copied organizations to be altered without copying unchanging data</p>
<h1><a class="anchor" id="autotoc_md115"></a>
ğŸŒˆ Segment : One ring to bind them all</h1>
<p>All of the different components of a mill (box, bus, logic (operations and actions), stack, shells, elements, gems, mill relations and inheritance and overrides) all use the same data structure/db table. This is useful/needed for the organizing of these through selections later</p>
<p>The type of thing each segment is can be determined by the trait role, as every entry here has its own dedicated trait</p>
<p>each different âš‘ flag value, across all columns in this table, has a different integer representing it, so that it's easy to find, set, mix and match different flags and see what is valid</p>
<p>If a trait has write access to the id-trait, then that trait has permissions to write to any part of that segment, and can delete it. Segments who have id-traits that are system traits can only be deleted by other system traits</p>
<h2><a class="anchor" id="autotoc_md116"></a>
Segment data structure (table)</h2>
<ul>
<li>ğŸ†” ğŸ”¤ GUID<ul>
<li><b>Auto generated string guid, can use in api calls</b></li>
</ul>
</li>
<li>/ ğŸ­ mill owner<ul>
<li>The mill this belongs to</li>
<li>This can be null for selections</li>
</ul>
</li>
<li>/ ğŸ†” the id-trait<ul>
<li>which gives this identity, permissions, relationship and ownership</li>
</ul>
</li>
<li>ğš« json data<ul>
<li>ğŸ“¦ for boxes, this is where the main info is stored</li>
<li>â‰£ ğŸ“¦ for stacked boxes, this is there copy of the data of the box they use</li>
<li>ğŸ“£ semaphores, properties stored in two keys</li>
<li>âˆ« ğŸ selection rules, when they use literal data</li>
<li>âˆ« â–¶ selection actions, when it uses literal data for args to its operations<ul>
<li>will always be numbers or strings, no geometry needed</li>
</ul>
</li>
<li>selection-active-paging, stores the variables (all of them in one json)</li>
<li><b>Geometric data can also be stored in the area and location too, however, when that happens, the geo-json its from is found here</b></li>
</ul>
</li>
<li>ğŸ’  multipolygon for associating area<ul>
<li>ğŸ“¦ for boxes, stores the area set by the geojson in the ğš« data</li>
<li>â‰£ ğŸ“¦ for stacked boxes, stores overridden (their copy) area from their data</li>
<li>âˆ« ğŸ selection rules, when the ğš« data has geojson area</li>
</ul>
</li>
<li>ğŸ“ location for a place in the world, or other<ul>
<li>ğŸ“¦ for boxes, stores the point set by the geojson in the ğš« data</li>
<li>â‰£ ğŸ“¦ for stacked boxes, stores overridden (their copy) point from their data</li>
<li>âˆ« ğŸ selection rules, when the ğš« data has geojson location</li>
</ul>
</li>
<li>/ ğŸŒ mapped world trait<ul>
<li>â‰£ for stacks, there needs to be one world it belongs to</li>
</ul>
</li>
<li>/ â—“ shard trait<ul>
<li>Everything with location belongs to a shard</li>
</ul>
</li>
<li>/ ğŸŒ nested world trait<ul>
<li>nested worlds do not interact, just run in the same library</li>
<li>nested worlds can have their own mapped worlds</li>
</ul>
</li>
<li>/ parent trait<ul>
<li>âš™ â–¶ for logic actions, this connects them with the logic trigger</li>
<li>â‰£ for stacks, this is the parent pointer (can be null if this is the first stack for it)</li>
<li>â‰£ ğŸšŒ for stacked buses, this is the stack owner</li>
<li>â‰£ ğŸ“¦ for stacked boxes, this is the stack owner</li>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the organization which is copied</li>
<li>âˆ« â–¶ selection actions, this connects them with the âˆ« ğŸ selection rule</li>
<li>selection-active-paging, this connects them with the âˆ« ğŸ selection rule</li>
<li>ğŸ“£ semaphores,when a context is given, then a child of the semaphore will be spun up and given its own row</li>
</ul>
</li>
<li>/ ğ° the alpha trait, which is used differently for each role<ul>
<li>ğŸ“¦ for boxes, a possible link to another trait id that describes this box. This is called the descriptor trait</li>
<li>ğŸšŒ for buses, this is the first trait</li>
<li>âš™ ğŸ for logic triggers, this is the first operand trait_ _</li>
<li>âš™ â–¶ for logic actions, this is the action tag</li>
<li>â‰£ for stacks, this is the context</li>
<li>â‰£ ğŸšŒ for stacked buses, this is the first trait</li>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this is the parent ğŸ­ mill</li>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the owner ğŸ­ğŸ“‚ Mill Organization</li>
<li>âˆ« ğŸ selection rules, this is the first operand trait</li>
<li>âˆ« â–¶ selection actions, this is the first operand trait</li>
</ul>
</li>
<li>/ ğ« the beta trait, which is used differently for each role<ul>
<li>ğŸ“¦ âˆ« for boxes, stores the selection trait</li>
<li>ğŸšŒ for buses, this is the second trait</li>
<li>âš™ ğŸ for logic triggers, this is the second operand trait</li>
<li>âš™ â–¶ for logic actions, this is the association tag</li>
<li>â‰£ ğŸšŒ for stacked buses, this is the second trait</li>
<li>â‰£ ğŸ“¦ âˆ« for stacked boxes, stores overridden (their copy) selection</li>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this is the child ğŸ­ mill</li>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the child ğŸ­ mill</li>
<li>âˆ« ğŸ selection rules, this is the second operand trait</li>
<li>âˆ« â–¶ selection actions, this is the second operand trait</li>
</ul>
</li>
<li>/ ğ® the grouping trait<ul>
<li>ğŸšŒ for buses, this is used to form collections and bind group buses for logic</li>
<li>âš™ â–¶ for logic actions, this is the grouping trait</li>
<li>âš™ ğŸ for logic triggers, this is the bus group that will active the top rule</li>
<li>â‰£ ğŸšŒ for stacked buses, this is local collection trait</li>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the child being added or removed from a copied structure</li>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this lists the trait (bus,box,logic) that is being overridden</li>
</ul>
</li>
<li>/ â— the target trait<ul>
<li>âš™ â–¶ for logic actions, this is used to define the target of the action</li>
<li>âš™ ğŸ for logic triggers, this is the bus that will active the top rule</li>
<li>â‰£ ğŸšŒ for stacked buses, this is the ğŸšŒ pointer to the original bus</li>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this maps what the grouping trait (the overridden) is being mapped to. Can be null to make it map to nothing</li>
<li>âˆ« â–¶ for selection actions, this is trait that receive the results of the api call in the ğš« json , it must have an entry on the segments</li>
<li>ğŸ“£ semaphores,when emitting, only this stack â‰£ and its children can hear this</li>
</ul>
</li>
<li>âš‘ operational flag, which is used differently for each role<ul>
<li>ğŸ“¦ for boxes, can a descendant â‰£ ğŸ“¦ write to this ?</li>
<li>â‰£ ğŸ“¦ for stacked boxes, can a descendant â‰£ ğŸ“¦ write to this ?</li>
<li>âš™ ğŸ for logic triggers, this is the operator</li>
<li>â‰£ for stacks, this shows if there can be dynamic data copying</li>
<li>ğŸ­ ğŸ“‚ for mill organization, this shows if we are adding or removing the child from the inherited list</li>
<li>âˆ« ğŸ selection rules, this is the operator</li>
<li>âˆ« â–¶ selection actions, this is the operator</li>
</ul>
</li>
<li>âš‘ descriptor flag, which is used differently for each role<ul>
<li>ğŸšŒ for buses, it is the type of bus entry</li>
<li>ğŸ“¦ for boxes, this gives hints on how to share the dynamic data with other worlds</li>
</ul>
</li>
<li>âš‘ contextual flag, which is used differently for each role<ul>
<li>ğŸšŒ for buses, tells if this is dynamic or static</li>
<li>ğŸ“¦ for boxes, tells if this is dynamic or static</li>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this is the type of role the child does</li>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the type of relationship</li>
<li>âˆ« â–¶ selection actions, how to use the selection results in that call</li>
</ul>
</li>
<li>ğŸ›ˆ ğ° counter, which is used differently for each role<ul>
<li>ğŸšŒ for buses, is the tag counter</li>
<li>â‰£ for stacks, this is the number of child stacks allowed</li>
<li>â‰£ ğŸšŒ for stacked buses, is the current tag counter</li>
<li>âš™ ğŸ for logic triggers, is the order which top rules will run</li>
<li>âš™ â–¶ for logic actions, is the order which top actions will run for the same rule</li>
<li>âˆ« ğŸ selection rules, the size of the page</li>
<li>âˆ« â–¶ selection actions, tells how many actions to do per page</li>
<li>selection-active-paging, the current page</li>
<li>ğŸ“£ semaphores,the minimum number of emit commands needed to toggle this emit</li>
</ul>
</li>
<li>ğŸ›ˆ ğ« counter, which is used differently for each role<ul>
<li>ğŸ“¦ for boxes, â†ª turn this was last updated on</li>
<li>â‰£ for stacks, , â†ª turn this was last updated on</li>
<li>â‰£ ğŸšŒ for stacked buses, is the old tag counter</li>
<li>â‰£ ğŸ“¦ for stacked boxes, â†ª turn this was last updated on</li>
<li>selection-active-paging, turn this page was created on</li>
<li>âˆ« â–¶ selection actions, tells how many pages to do actions on</li>
<li>ğŸ“£ semaphores,the number of emit commands given to it</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md117"></a>
ğŸ‘ª Inheritance of ğŸ­ mills</h1>
<h2><a class="anchor" id="autotoc_md118"></a>
Inheritance</h2>
<p>New mills can be made from 1 or more copies of other mills. If the new mill does not override the ğŸ“¦ boxes, âš™ logic, or ğŸšŒ buses of the parent, then the parents can be used to select the child (or descendants)</p>
<p>Since there can be multiple inheritance, and ancestors can block selections by overriding parents. There is a table for inheritance in mills</p>
<p>In the data structures, simply create a new trait which will be the parent, and then add in the inheritance to the table below. There will be no new buses, logic or boxes made. The descendants share any static data or settings. But, the descendants can create new boxes, logic and buses. If the new ones do not change the inherited ones (use the same traits in the sub structures and add or remove things that modify them), then this inheritance is called pure. However, pure descendants can add in unrelated things that do not impact the ancestor data or behaviors, and still be pure</p>
<p>Any child can override a bus,box, logic from an ancestor. If this has multiple inheritance which has two or more ancestors that share the same sub structure trait for a bus,box or logic, then one is randomly chosen, unless there is a mapping</p>
<p>Mills can be created to inherit and override other mills, and mill can have structures made out of other mills</p>
<p>A child mill will inherit all the sub mills without creating new entries, any changes to any gems inherited, for example, will create a entry in the mill organization structure, which flags what kind of change this is, and will automatically will mark the inheritance as not pure</p>
<p>To be considered a change of inherited mill organization, the relationship type must be the same as one of the types the parent uses. If the child uses a new type of relationship, then the changes do not pure state</p>
<h2><a class="anchor" id="autotoc_md119"></a>
ğŸ­ ğŸ‘ª  Mill Inheritance data</h2>
<ul>
<li>/ ğŸ­ mill owner<ul>
<li>The mill that owns this ğŸ‘ª ğŸ­ rule</li>
</ul>
</li>
<li>/ ğŸ†” the id-trait<ul>
<li>the unique trait generated for this ğŸ‘ª ğŸ­ rule</li>
<li>all ğŸ‘ª rules for the ğŸ­ are siblings</li>
</ul>
</li>
<li>/ ğ° the alpha trait<ul>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this is the parent ğŸ­ mill that we are inheriting from</li>
<li>Can be null if we are creating a brand new mill, to define it to have a role</li>
</ul>
</li>
<li>/ ğ« the beta trait<ul>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this is the child ğŸ­ mill that inherits</li>
</ul>
</li>
<li>/ ğ® the grouping trait<ul>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this lists the trait (bus,box,logic) that is being overridden</li>
</ul>
</li>
<li>/ â— the target trait<ul>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this maps what the grouping trait (the overridden) is being mapped to. Can be null to make it map to nothing</li>
<li>Mapping has to stay in the same type: map bus to bus, for example</li>
</ul>
</li>
<li>âš‘ contextual flag<ul>
<li>ğŸ­ ğŸ‘ª for mill inheritance, this is the type of role the child does</li>
<li>if several rows define this inheritance, it only has to be set once, and the rest of the rows it can be null</li>
<li>it must be set once and only once for each mill created</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md120"></a>
ğŸ“‚ ğŸ­ Grouping and Structures of Mills</h1>
<p><em>Usually , Mills do not operate alone, and are organized to work together. For example, interfaces have gems, shells have element lists, promises have handlers</em></p>
<p><em>Mills that do not inherit a structure from a parent make their own lists</em></p>
<h2><a class="anchor" id="autotoc_md121"></a>
Mill Organization Data</h2>
<ul>
<li>/ ğŸ­ mill owner<ul>
<li>The mill that owns this ğŸ“‚ ğŸ­ rule</li>
</ul>
</li>
<li>/ ğŸ†” the id-trait<ul>
<li>the unique trait generated for this ğŸ“‚ ğŸ­ rule</li>
<li>all ğŸ“‚ rules for the ğŸ­ are siblings</li>
</ul>
</li>
<li>/ parent trait<ul>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the organization which is copied</li>
<li>can be null if this starts a new organization</li>
</ul>
</li>
<li>/ ğ° the alpha trait<ul>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the owner ğŸ­ğŸ“‚ Mill Organization</li>
</ul>
</li>
<li>/ ğ« the beta trait<ul>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the child ğŸ­ mill</li>
</ul>
</li>
<li>/ ğ® the grouping trait<ul>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the child being added to or removed from the parent organization</li>
<li>if there is no parent organization, this defines the list</li>
</ul>
</li>
<li>âš‘ operational flag<ul>
<li>ğŸ­ ğŸ“‚ for mill organization, this shows if we are adding or removing the child from the inherited list</li>
</ul>
</li>
<li>âš‘ contextual flag<ul>
<li>ğŸ­ ğŸ“‚ for mill organization, this is the type of relationship</li>
</ul>
</li>
</ul>
<h1><a class="anchor" id="autotoc_md122"></a>
@ Tags and how they are used</h1>
<p>Tags are used to store state. Symbolized by the @ symbol here, they are traits that are of type tag. A trait that is used as a tag cannot be used as anything else, but anything that can select that tag can use it for associative tagging, and anything that has permission to write to the bus trait , and can see a tag, can tag that bus with that tag</p>
<p>Tags can be pushed (add a row or count) or popped (remove a row or decrease the count) from a bus on a mill or stack. When a tag is pushed onto a trait, if there is no extra data in that push other than the tag.Then this is called a regular tag. And this kind of tag only has one entry on the bus. The number of times that tag is pushed - the number of times that tag is popped, is kept as the count on that bus entry. The tag number can never get less than 0, no matter how many times it's popped, but can be any positive number based on how many times that it is pushed. A tag is present anytime its count is &gt; 0.</p>
<p>ğŸ‘£ A associated tag can be assigned a trait to pair up with, regardless of permissions. If the associated tag is pushed twice with the same trait, then its count increases just like a regular tag that has no associated data. And that count is kept on the bus entry which has that pair recorded</p>
<p>Associated tags is how we store collections or groups</p>
<p>Tags can be related together in two ways.</p>
<ul>
<li>Through relationship (all the tags of one thing can be descended from a certain tag, to treat it like a file structure, if needed)</li>
<li><p class="startli">And each tag can be given a group on the bus</p><ul>
<li>This group trait does not have to be related to anything</li>
<li>If the same tag is pushed with a different group from last time, then that is a new bus entry, regardless if there is also associated data</li>
</ul>
<p class="startli">Selections can use tag relationships to filter out and focus only on some things. In addition, the caller of the selection can use its associated tags to pre-filter the selection</p>
</li>
</ul>
<p>The general rule of thumb is that tags can be pushed and popped from a bus by anything that has permission, and that is how that mill or element state is maintained, if the logic on there will listen to the tags. If a tag is pushed or popped from a bus, and no logic rules are listening to that bus trait (or family as new buses have descendant traits related to the older ones), then the tag push or pop may help with selections done by other things later </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
